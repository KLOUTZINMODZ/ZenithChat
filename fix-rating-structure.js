require('dotenv').config();
const mongoose = require('mongoose');

async function fixRatingStructure() {
  try {
    console.log('üîó Conectando ao MongoDB...');
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('‚úÖ Conectado ao MongoDB');

    const db = mongoose.connection.db;
    const usersCollection = db.collection('users');

    console.log('üîÑ Verificando estrutura dos campos rating...');
    
    // Busca usu√°rios com rating como n√∫mero (estrutura incorreta)
    const usersWithNumberRating = await usersCollection.find({
      rating: { $type: 'number' }
    }).toArray();

    console.log(`üìä Encontrados ${usersWithNumberRating.length} usu√°rios com rating como n√∫mero`);

    if (usersWithNumberRating.length > 0) {
      console.log('\nüîß Convertendo ratings de n√∫mero para objeto...');
      
      for (const user of usersWithNumberRating) {
        const oldRating = user.rating || 0;
        
        // Converte para estrutura de objeto
        await usersCollection.updateOne(
          { _id: user._id },
          {
            $set: {
              rating: {
                average: oldRating,
                count: 0
              }
            }
          }
        );
        
        console.log(`‚úÖ Convertido: ${user.name} - rating ${oldRating} ‚Üí {average: ${oldRating}, count: 0}`);
      }
      
      console.log(`\n‚úÖ ${usersWithNumberRating.length} usu√°rios convertidos com sucesso!`);
    }

    // Busca usu√°rios sem o campo rating
    const usersWithoutRating = await usersCollection.find({
      rating: { $exists: false }
    }).toArray();

    console.log(`\nüìä Encontrados ${usersWithoutRating.length} usu√°rios sem campo rating`);

    if (usersWithoutRating.length > 0) {
      console.log('\nüîß Adicionando campo rating...');
      
      await usersCollection.updateMany(
        { rating: { $exists: false } },
        {
          $set: {
            rating: {
              average: 0,
              count: 0
            }
          }
        }
      );
      
      console.log(`‚úÖ ${usersWithoutRating.length} usu√°rios atualizados com campo rating`);
    }

    // Verifica usu√°rios com rating.average faltando
    const usersWithoutAverage = await usersCollection.find({
      'rating.average': { $exists: false },
      rating: { $exists: true, $type: 'object' }
    }).toArray();

    console.log(`\nüìä Encontrados ${usersWithoutAverage.length} usu√°rios com rating sem average`);

    if (usersWithoutAverage.length > 0) {
      console.log('\nüîß Adicionando rating.average...');
      
      await usersCollection.updateMany(
        {
          'rating.average': { $exists: false },
          rating: { $exists: true, $type: 'object' }
        },
        {
          $set: {
            'rating.average': 0,
            'rating.count': 0
          }
        }
      );
      
      console.log(`‚úÖ ${usersWithoutAverage.length} usu√°rios atualizados com rating.average`);
    }

    // Mostra estat√≠sticas finais
    console.log('\nüìä Estat√≠sticas finais:');
    const totalUsers = await usersCollection.countDocuments({});
    const usersWithCorrectRating = await usersCollection.countDocuments({
      'rating.average': { $exists: true },
      'rating.count': { $exists: true }
    });

    console.log(`- Total de usu√°rios: ${totalUsers}`);
    console.log(`- Usu√°rios com rating correto: ${usersWithCorrectRating}`);
    console.log(`- Porcentagem: ${((usersWithCorrectRating / totalUsers) * 100).toFixed(2)}%`);

    // Amostra de usu√°rios
    console.log('\nüìã Amostra de usu√°rios (primeiros 5):');
    const sampleUsers = await usersCollection.find({}).limit(5).toArray();
    sampleUsers.forEach(user => {
      console.log(`- ${user.name}:`);
      console.log(`  rating.average: ${user.rating?.average || 'N/A'}`);
      console.log(`  rating.count: ${user.rating?.count || 'N/A'}`);
    });

    console.log('\n‚úÖ Corre√ß√£o conclu√≠da com sucesso!');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Erro ao corrigir estrutura:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
}

fixRatingStructure();
