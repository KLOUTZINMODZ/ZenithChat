const mongoose = require('mongoose');
require('dotenv').config();

const Agreement = require('./src/models/Agreement');
const AcceptedProposal = require('./src/models/AcceptedProposal');
const Conversation = require('./src/models/Conversation');
const User = require('./src/models/User');

async function createMissingAgreements() {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    
    console.log('‚úÖ Conectado ao MongoDB');
    console.log('üîç Buscando conversas de boosting sem Agreement...\n');
    
    // Primeiro, vamos ver TODAS as conversas para entender a estrutura
    const allConversations = await Conversation.find({}).limit(10);
    console.log('üìã Primeiras 10 conversas no banco:');
    allConversations.forEach((conv, idx) => {
      console.log(`   ${idx + 1}. _id: ${conv._id}`);
      console.log(`      type: ${conv.type}`);
      console.log(`      isTemporary: ${conv.isTemporary}`);
      console.log(`      status: ${conv.status}`);
      console.log(`      boostingStatus: ${conv.boostingStatus}`);
      console.log(`      participants: ${conv.participants?.length || 0}`);
    });
    console.log('');
    
    // Buscar conversas de boosting com crit√©rios mais flex√≠veis
    const conversations = await Conversation.find({
      $or: [
        { type: 'boosting' },
        { boostingStatus: { $exists: true } },
        { 'metadata.boostingId': { $exists: true } }
      ],
      isTemporary: false
    });
    
    console.log(`üìä Total de conversas de boosting encontradas: ${conversations.length}\n`);
    
    let created = 0;
    let alreadyExists = 0;
    let errors = 0;
    
    for (const conv of conversations) {
      try {
        console.log('='.repeat(80));
        console.log(`üîç Processando conversa: ${conv._id}`);
        console.log(`   Status: ${conv.status}, BoostingStatus: ${conv.boostingStatus}`);
        
        // Verifica se j√° existe Agreement
        const existingAgreement = await Agreement.findOne({ conversationId: conv._id });
        
        if (existingAgreement) {
          console.log(`‚úÖ Agreement j√° existe: ${existingAgreement.agreementId}`);
          alreadyExists++;
          continue;
        }
        
        console.log('üìù Agreement n√£o existe, criando...');
        
        // Extrair dados da conversa
        const metadata = conv.metadata instanceof Map 
          ? Object.fromEntries(conv.metadata) 
          : (conv.metadata || {});
        
        const proposalData = metadata.proposalData || {};
        
        console.log('   Metadata:', JSON.stringify(metadata, null, 2));
        
        // Identificar participantes (cliente e booster)
        const participants = conv.participants || [];
        if (participants.length < 2) {
          console.error(`‚ùå Conversa sem participantes suficientes: ${participants.length}`);
          errors++;
          continue;
        }
        
        // Tentar identificar cliente e booster
        let clientId, boosterId;
        
        // Op√ß√£o 1: Metadata tem client e booster
        if (metadata.clientId) {
          clientId = metadata.clientId;
        }
        if (metadata.boosterId) {
          boosterId = metadata.boosterId;
        }
        
        // Op√ß√£o 2: AcceptedProposal
        if (!clientId || !boosterId) {
          const acceptedProposal = await AcceptedProposal.findOne({ conversationId: conv._id });
          if (acceptedProposal) {
            clientId = acceptedProposal.client?.userid || clientId;
            boosterId = acceptedProposal.booster?.userid || boosterId;
            console.log('   Found AcceptedProposal:', {
              clientId,
              boosterId,
              price: acceptedProposal.price
            });
          }
        }
        
        // Op√ß√£o 3: Assumir primeiro participante √© cliente, segundo √© booster
        if (!clientId) {
          clientId = participants[0];
          console.log(`   Assuming participant[0] is client: ${clientId}`);
        }
        if (!boosterId) {
          boosterId = participants[1];
          console.log(`   Assuming participant[1] is booster: ${boosterId}`);
        }
        
        // Buscar dados dos usu√°rios
        const clientUser = await User.findById(clientId);
        const boosterUser = await User.findById(boosterId);
        
        if (!clientUser) {
          console.error(`‚ùå Cliente n√£o encontrado: ${clientId}`);
          errors++;
          continue;
        }
        
        if (!boosterUser) {
          console.error(`‚ùå Booster n√£o encontrado: ${boosterId}`);
          errors++;
          continue;
        }
        
        console.log('   ‚úÖ Users found:', {
          client: clientUser.name,
          booster: boosterUser.name
        });
        
        // Extrair dados da proposta
        const proposalId = metadata.proposalId || metadata.actualProposalId || conv.proposal;
        const proposalPrice = proposalData.price || acceptedProposal?.price || metadata.price || metadata.proposedPrice || 0;
        
        console.log('   Proposal data:', {
          proposalId,
          proposalPrice,
          game: proposalData.game || metadata.game,
          category: proposalData.category || metadata.category,
          description: proposalData.description || metadata.description
        });
        
        if (!proposalPrice || proposalPrice <= 0) {
          console.error(`‚ùå Pre√ßo inv√°lido: ${proposalPrice}`);
          errors++;
          continue;
        }
        
        // Validar proposalId √© ObjectId v√°lido
        if (!mongoose.Types.ObjectId.isValid(proposalId)) {
          console.warn(`‚ö†Ô∏è ProposalId n√£o √© ObjectId v√°lido: ${proposalId}, usando conversationId`);
        }
        
        // Criar Agreement
        const agreement = new Agreement({
          conversationId: conv._id,
          proposalId: mongoose.Types.ObjectId.isValid(proposalId) ? proposalId : conv._id,
          proposalSnapshot: {
            game: proposalData.game || metadata.game || 'N/A',
            category: proposalData.category || metadata.category || metadata.boostingCategory || 'Boosting',
            currentRank: proposalData.currentRank || metadata.currentRank || 'N/A',
            desiredRank: proposalData.desiredRank || metadata.desiredRank || 'N/A',
            description: proposalData.description || metadata.description || proposalData.message || metadata.message || 'Servi√ßo de boosting',
            price: proposalPrice,
            originalPrice: proposalPrice,
            estimatedTime: proposalData.estimatedTime || metadata.estimatedTime || '1 hora'
          },
          parties: {
            client: {
              userid: clientId,
              name: clientUser.name || clientUser.username,
              email: clientUser.email,
              avatar: clientUser.avatar,
              metadata: new Map([
                ['isVerified', clientUser.isVerified || false],
                ['totalOrders', clientUser.totalOrders || 0],
                ['rating', clientUser.rating || 0]
              ])
            },
            booster: {
              userid: boosterId,
              name: boosterUser.name || boosterUser.username,
              email: boosterUser.email,
              avatar: boosterUser.avatar,
              rating: boosterUser.rating || 0,
              metadata: new Map([
                ['isVerified', boosterUser.isVerified || false],
                ['totalBoosts', boosterUser.totalBoosts || 0],
                ['completedBoosts', boosterUser.completedBoosts || 0]
              ])
            }
          },
          financial: {
            totalAmount: proposalPrice,
            currency: 'BRL',
            paymentStatus: 'pending'
          },
          status: conv.boostingStatus === 'completed' ? 'completed' : 'active'
        });
        
        agreement.addAction('created', clientId, { 
          proposalId: proposalId,
          migratedFrom: 'conversation',
          migrationDate: new Date()
        });
        
        // Se j√° foi completado, adicionar action
        if (conv.boostingStatus === 'completed') {
          agreement.addAction('completed', clientId, {
            completedAt: conv.deliveryConfirmedAt || new Date(),
            migratedCompletion: true
          });
        }
        
        await agreement.save();
        
        // Atualizar conversa com agreementId
        conv.metadata = conv.metadata || new Map();
        if (conv.metadata instanceof Map) {
          conv.metadata.set('latestAgreementId', agreement.agreementId);
        } else {
          conv.metadata.latestAgreementId = agreement.agreementId;
        }
        await conv.save();
        
        console.log(`‚úÖ Agreement criado com sucesso: ${agreement.agreementId}`);
        console.log(`   ConversationId: ${agreement.conversationId}`);
        console.log(`   ProposalId: ${agreement.proposalId}`);
        console.log(`   Price: R$ ${agreement.proposalSnapshot.price}`);
        console.log(`   Status: ${agreement.status}`);
        
        created++;
        
      } catch (error) {
        console.error(`‚ùå Erro ao processar conversa ${conv._id}:`, error.message);
        console.error('   Stack:', error.stack);
        errors++;
      }
    }
    
    console.log('\n' + '='.repeat(80));
    console.log('üìä RESUMO DA MIGRA√á√ÉO');
    console.log('='.repeat(80));
    console.log(`Total de conversas processadas: ${conversations.length}`);
    console.log(`‚úÖ Agreements criados: ${created}`);
    console.log(`‚ÑπÔ∏è  Agreements j√° existiam: ${alreadyExists}`);
    console.log(`‚ùå Erros: ${errors}`);
    console.log('='.repeat(80));
    
    if (created > 0) {
      console.log('\n‚úÖ Migra√ß√£o conclu√≠da com sucesso!');
      console.log('üí° Agora voc√™ pode confirmar entregas normalmente.');
    } else if (alreadyExists > 0) {
      console.log('\n‚úÖ Todos os Agreements j√° existiam.');
    } else {
      console.log('\n‚ö†Ô∏è Nenhum Agreement foi criado. Verifique os erros acima.');
    }
    
  } catch (error) {
    console.error('‚ùå Erro fatal:', error.message);
    console.error(error.stack);
  } finally {
    await mongoose.disconnect();
    console.log('\n‚úÖ Desconectado do MongoDB');
  }
}

createMissingAgreements();
