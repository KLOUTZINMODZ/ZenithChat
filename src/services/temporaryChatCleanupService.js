const Conversation = require('../models/Conversation');
const Message = require('../models/Message');
const logger = require('../utils/logger');

class TemporaryChatCleanupService {
  constructor() {
    this.isRunning = false;
    this.intervalId = null;
  }


  start() {
    if (this.isRunning) {
      logger.warn('Servi√ßo de limpeza de chats tempor√°rios j√° est√° rodando');
      return;
    }



    this.cleanupExpiredChats().catch((err) => {
      logger.error('Erro na execu√ß√£o inicial da limpeza de chats tempor√°rios:', err);
    });

    this.intervalId = setInterval(() => {
      this.cleanupExpiredChats().catch((err) => {
        logger.error('Erro na execu√ß√£o agendada da limpeza de chats tempor√°rios:', err);
      });
    }, 3600000);

    this.isRunning = true;
    logger.info('‚úÖ Servi√ßo de limpeza de chats tempor√°rios iniciado (executa a cada hora)');
  }


  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.isRunning = false;
    logger.info('üõë Servi√ßo de limpeza de chats tempor√°rios parado');
  }


  async cleanupExpiredChats() {
    try {
      logger.info('üßπ Iniciando limpeza de chats tempor√°rios expirados...');

      const expiredChats = await Conversation.find({
        isTemporary: true,
        status: 'pending',
        expiresAt: { $lt: new Date() }
      });

      if (expiredChats.length === 0) {
        logger.info('‚úÖ Nenhum chat tempor√°rio expirado encontrado');
        return { cleanedCount: 0 };
      }

      logger.info(`üîç Encontrados ${expiredChats.length} chats tempor√°rios expirados`);

      let cleanedCount = 0;
      let errorCount = 0;

      for (const chat of expiredChats) {
        try {

          await chat.expireTemporaryChat();
          

          const expirationMessage = new Message({
            conversation: chat._id,
            content: 'üö´ Este chat expirou porque a proposta n√£o foi aceita em at√© 3 dias.',
            type: 'system',
            metadata: {
              type: 'chat_expired',
              expiredAt: new Date(),
              autoCleanup: true
            }
          });

          await expirationMessage.save();
          

          chat.lastMessage = expirationMessage._id;
          chat.lastMessageAt = new Date();
          await chat.save();
          
          cleanedCount++;
          logger.info(`‚úÖ Chat ${chat._id} expirado com sucesso`);
          
        } catch (error) {
          errorCount++;
          logger.error(`‚ùå Erro ao expirar chat ${chat._id}:`, error);
        }
      }

      const result = {
        totalFound: expiredChats.length,
        cleanedCount,
        errorCount,
        timestamp: new Date()
      };

      logger.info(`üßπ Limpeza conclu√≠da: ${cleanedCount} chats expirados, ${errorCount} erros`);
      
      return result;

    } catch (error) {
      logger.error('‚ùå Erro durante limpeza de chats tempor√°rios:', error);
      throw error;
    }
  }


  async manualCleanup() {
    logger.info('üßπ Executando limpeza manual de chats tempor√°rios...');
    return await this.cleanupExpiredChats();
  }


  async getStats() {
    try {
      const stats = await Promise.all([

        Conversation.countDocuments({
          isTemporary: true,
          status: 'pending',
          expiresAt: { $gt: new Date() }
        }),
        

        Conversation.countDocuments({
          isTemporary: true,
          status: 'pending',
          expiresAt: { $lt: new Date() }
        }),
        

        Conversation.countDocuments({
          isTemporary: true,
          status: 'expired'
        }),
        

        Conversation.countDocuments({
          isTemporary: false,
          status: 'active',
          metadata: { $exists: true }
        })
      ]);

      return {
        activePending: stats[0],
        expiredPending: stats[1], 
        expired: stats[2],
        converted: stats[3],
        total: stats[0] + stats[1] + stats[2],
        needsCleanup: stats[1] > 0
      };
    } catch (error) {
      logger.error('Erro ao obter estat√≠sticas de chats tempor√°rios:', error);
      throw error;
    }
  }


  getStatus() {
    return {
      isRunning: this.isRunning,
      nextRun: this.job ? this.job.nextDate() : null,
      timezone: 'America/Sao_Paulo'
    };
  }
}

module.exports = new TemporaryChatCleanupService();
