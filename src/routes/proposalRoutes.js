const express = require('express');
const router = express.Router();
const { auth } = require('../middleware/auth');


const axios = require('axios');
const Conversation = require('../models/Conversation');
const Message = require('../models/Message');
const Agreement = require('../models/Agreement');
const AcceptedProposal = require('../models/AcceptedProposal');


router.get('/', (req, res) => {
  res.json({
    message: 'Proposals API',
    endpoints: {
      accept: 'POST /:proposalId/accept'
    },
    timestamp: new Date().toISOString()
  });
});


router.get('/:proposalId/accept', auth, async (req, res) => {
  try {
    const { proposalId } = req.params;
    
    console.log(`üîç [Proposal Accept GET] Received request for proposal: ${proposalId}`);
    

    res.status(405).json({
      success: false,
      message: 'Method Not Allowed. Use POST method to accept proposals.',
      allowedMethods: ['POST'],
      endpoint: `POST /api/proposals/${proposalId}/accept`,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå [Proposal Accept GET] Error:', error.message);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

router.post('/:proposalId/accept', auth, async (req, res) => {
  try {
    const { proposalId } = req.params;
    let { conversationId, boosterId, clientId, metadata = {} } = req.body;
    let actualProposalId = proposalId;
    let boostingId = metadata?.boostingId;
    let lookupData = null;
    
    // Normaliza IDs que podem vir como objetos
    if (typeof boosterId === 'object' && boosterId) {
      boosterId = boosterId._id || boosterId.id;
    }
    if (typeof clientId === 'object' && clientId) {
      clientId = clientId._id || clientId.id;
    }

    console.log(`üîç [Proposal Accept] Received request for proposal: ${proposalId}`);
    console.log(`üîç [Proposal Accept] ConversationId: ${conversationId}`);
    console.log(`üîç [Proposal Accept] BoosterId (normalized): ${boosterId}`);
    console.log(`üîç [Proposal Accept] ClientId (normalized): ${clientId}`);
    console.log(`üîç [Proposal Accept] Metadata:`, metadata);
    console.log(`üîç [Proposal Accept] Checking boostingId: ${boostingId} (type: ${typeof boostingId})`);
    console.log(`üîç [Proposal Accept] Metadata boostingId exists: ${!!metadata?.boostingId}`);
    console.log(`üîç [Proposal Accept] Metadata proposalId: ${metadata?.proposalId}`);
    

    if (metadata?.proposalId) {
      actualProposalId = metadata.proposalId;
      console.log(`‚úÖ [Proposal Accept] Using proposalId from metadata: ${actualProposalId}`);
    }
    
    if (!boostingId) {
      console.log(`‚ö†Ô∏è [Proposal Accept] No boostingId in metadata, attempting database lookup for proposalId: ${proposalId}`);
      
      try {

        const proposalLookupUrl = `${process.env.HACKLOTE_API_URL || 'https://zenithggapi.vercel.app/api'}/proposals/${proposalId}/boosting-id`;
        console.log(`üîç [Proposal Accept] Looking up boostingId at: ${proposalLookupUrl}`);
        
        const lookupResponse = await axios.get(proposalLookupUrl, {
          headers: { Authorization: req.headers.authorization }
        });
        
        console.log('‚úÖ [Proposal Accept] Lookup successful:', lookupResponse.data);
        lookupData = lookupResponse.data;
        boostingId = lookupResponse.data.boostingId;
        

        if (lookupResponse.data.actualProposalId) {
          actualProposalId = lookupResponse.data.actualProposalId;
          console.log('‚úÖ [Proposal Accept] Using actualProposalId from lookup:', actualProposalId);
        }
      } catch (lookupError) {
        console.log('‚ùå [Proposal Accept] Lookup failed:', lookupError.message);
        console.log('‚ùå [Proposal Accept] Lookup error details:', lookupError.response?.data);
        
        const mongoose = require('mongoose');
        if (mongoose.Types.ObjectId.isValid(proposalId)) {
          console.log('üîç [Proposal Accept] Checking if proposalId', proposalId, 'is actually a boostingId...');
          console.log('‚úÖ [Proposal Accept] ProposalId', proposalId, 'is a valid ObjectId, using as boostingId');
          boostingId = proposalId;
        } else {
          console.log('‚ùå [Proposal Accept] ProposalId is not a valid ObjectId, cannot proceed');
          return res.status(400).json({
            success: false,
            message: 'N√£o foi poss√≠vel encontrar o boostingId para esta proposta',
            details: {
              proposalId: proposalId,
              lookupUrl: `${process.env.HACKLOTE_API_URL || 'https://zenithggapi.vercel.app/api'}/proposals/${proposalId}/boosting-id`,
              originalError: lookupError.response?.data || lookupError.message
            }
          });
        }
      }
    }
    
    console.log(`üîç [Proposal Accept] Final BoostingId: ${boostingId}`);
    
    if (!boostingId || boostingId === 'undefined') {
      console.error(`‚ùå [Proposal Accept] Invalid boostingId: ${boostingId}`);
      return res.status(500).json({
        success: false,
        message: 'BoostingId inv√°lido ou n√£o encontrado',
        error: 'Invalid boostingId',
        details: {
          proposalId: proposalId,
          boostingId: boostingId,
          metadata: metadata
        }
      });
    }


    // Se proposalId cont√©m underscore, √© o formato composto (boostingId_boosterId_timestamp)
    // Precisamos buscar o ID real da proposta na API principal
    if (proposalId.includes('_')) {
      console.log(`üîç [Proposal Accept] ProposalId is composite format, need to find real proposal ID`);
      
      try {
        // Busca todas as propostas deste boosting request
        const proposalsUrl = `${process.env.HACKLOTE_API_URL || 'https://zenithggapi.vercel.app/api'}/boosting-requests/${boostingId}/proposals`;
        console.log(`üîó [Proposal Accept] Fetching proposals from: ${proposalsUrl}`);
        
        const proposalsResponse = await axios.get(proposalsUrl, {
          headers: { Authorization: req.headers.authorization }
        });
        
        const proposals = proposalsResponse.data.data || proposalsResponse.data.proposals || [];
        console.log(`‚úÖ [Proposal Accept] Found ${proposals.length} proposals for boosting ${boostingId}`);
        
        // Encontra a proposta do booster correto (boosterId j√° normalizado no in√≠cio)
        const boosterIdStr = String(boosterId);
        console.log(`üîç [Proposal Accept] Looking for proposal from booster: ${boosterIdStr}`);
        
        const matchingProposal = proposals.find(p => {
          const proposalBoosterId = String(p.boosterId?._id || p.boosterId || p.booster?._id || p.booster);
          console.log(`üîç [Proposal Accept] Comparing ${proposalBoosterId} === ${boosterIdStr}`);
          return proposalBoosterId === boosterIdStr;
        });
        
        if (matchingProposal) {
          actualProposalId = String(matchingProposal._id || matchingProposal.id);
          console.log(`‚úÖ [Proposal Accept] Found matching proposal ID: ${actualProposalId} for booster ${boosterIdStr}`);
        } else {
          console.error(`‚ùå [Proposal Accept] No matching proposal found for booster ${boosterIdStr}`);
          console.log(`üîç [Proposal Accept] Available proposals:`, proposals.map(p => ({
            id: p._id || p.id,
            boosterId: p.boosterId?._id || p.boosterId || p.booster?._id || p.booster,
            status: p.status
          })));
          
          // Se n√£o encontrou, retorna erro ao inv√©s de continuar
          return res.status(404).json({
            success: false,
            message: 'Proposta n√£o encontrada para este booster',
            details: {
              boostingId,
              boosterId: boosterIdStr,
              availableProposals: proposals.map(p => ({
                id: p._id || p.id,
                boosterId: p.boosterId?._id || p.boosterId,
                status: p.status
              }))
            }
          });
        }
      } catch (error) {
        console.log('‚ùå [Proposal Accept] Error fetching proposals:', error.message);
        console.log('‚ùå [Proposal Accept] Error details:', error.response?.data);
      }
    }
    
    // Se ainda n√£o temos actualProposalId, verifica conversation metadata
    if (!actualProposalId || actualProposalId.includes('_')) {
      console.log(`üîç [Proposal Accept] Checking conversation metadata for proposal ID`);
      
      try {
        const conversationResponse = await axios.get(`https://zenith.enrelyugi.com.br/api/conversations/${conversationId}`, {
          headers: { Authorization: req.headers.authorization }
        });
        
        const conversationData = conversationResponse.data;
        console.log('üîç [Proposal Accept] Conversation metadata:', JSON.stringify(conversationData?.metadata, null, 2));
        
        // N√£o usa metadata.proposalId se for formato composto
        if (conversationData?.metadata?.actualProposalId) {
          actualProposalId = conversationData.metadata.actualProposalId;
          console.log('‚úÖ [Proposal Accept] Found actualProposalId from conversation:', actualProposalId);
        }
      } catch (error) {
        console.log('‚ùå [Proposal Accept] Error fetching conversation metadata:', error.message);
      }
    }
    
    // Aceita proposta localmente primeiro (sistema h√≠brido)
    console.log('üìù [Proposal Accept] Accepting proposal locally in Chat API...');
    
    let acceptedConv = null;
    let agreementCreated = null;
    
    try {
      // 1. Buscar conversa
      if (conversationId) {
        acceptedConv = await Conversation.findById(conversationId);
      }
      if (!acceptedConv) {
        acceptedConv = await Conversation.findOne({
          isTemporary: true,
          $or: [
            { 'metadata.proposalId': proposalId },
            { 'metadata.proposalId': actualProposalId },
            { proposal: proposalId },
            { proposal: actualProposalId }
          ]
        });
      }

      if (!acceptedConv) {
        throw new Error('Conversa n√£o encontrada para aceitar proposta');
      }

      console.log('‚úÖ [Proposal Accept] Conversation found:', acceptedConv._id);
      
      // 2. ‚úÖ CR√çTICO: Criar Agreement ANTES de aceitar a conversa
      try {
          console.log('üìù [Proposal Accept] Creating Agreement for conversation...');
          
          // Verifica se j√° existe Agreement
          const existingAgreement = await Agreement.findOne({ conversationId });
          
          if (!existingAgreement) {
            console.log('üîç [Proposal Accept] Agreement does not exist, creating new one...');
            console.log('üîç [Proposal Accept] Creating Agreement with:', {
              conversationId,
              actualProposalId,
              clientId,
              boosterId,
              hasMetadata: !!metadata,
              hasProposalData: !!metadata?.proposalData
            });
            
            // Busca dados do cliente e booster
            const clientUser = await require('../models/User').findById(clientId);
            const boosterUser = await require('../models/User').findById(boosterId);
            
            console.log('üîç [Proposal Accept] Users found:', {
              clientUser: !!clientUser,
              boosterUser: !!boosterUser,
              clientName: clientUser?.name,
              boosterName: boosterUser?.name
            });
            
            if (!clientUser) {
              throw new Error(`Client user not found: ${clientId}`);
            }
            if (!boosterUser) {
              throw new Error(`Booster user not found: ${boosterId}`);
            }
            
            if (clientUser && boosterUser) {
              // Extrai dados da proposta (pode estar em metadata.proposalData ou direto no metadata)
              const proposalData = metadata?.proposalData || {};
              const proposalPrice = proposalData.price || metadata?.price || metadata?.proposedPrice || 0;
              
              console.log('üîç [Proposal Accept] Proposal data extracted:', {
                proposalPrice,
                game: proposalData.game || metadata?.game,
                category: proposalData.category || metadata?.category
              });
              
              if (!proposalPrice || proposalPrice <= 0) {
                throw new Error(`Invalid proposal price: ${proposalPrice}`);
              }
              
              // Validar e converter proposalId para ObjectId v√°lido
              const mongoose = require('mongoose');
              let validProposalId;
              
              if (mongoose.Types.ObjectId.isValid(actualProposalId) && !actualProposalId.includes('_')) {
                validProposalId = actualProposalId;
                console.log('‚úÖ [Proposal Accept] Using actualProposalId as ObjectId:', validProposalId);
              } else if (mongoose.Types.ObjectId.isValid(boostingId)) {
                validProposalId = boostingId;
                console.log('‚úÖ [Proposal Accept] ProposalId is composite, using boostingId:', validProposalId);
              } else {
                validProposalId = conversationId;
                console.log('‚ö†Ô∏è [Proposal Accept] Using conversationId as fallback:', validProposalId);
              }
              
              const agreement = new Agreement({
                conversationId,
                proposalId: validProposalId,
                proposalSnapshot: {
                  game: proposalData.game || metadata?.game || 'N/A',
                  category: proposalData.category || metadata?.category || metadata?.boostingCategory || 'Boosting',
                  currentRank: proposalData.currentRank || metadata?.currentRank || 'N/A',
                  desiredRank: proposalData.desiredRank || metadata?.desiredRank || 'N/A',
                  description: proposalData.description || metadata?.description || '',
                  price: proposalPrice,
                  originalPrice: proposalPrice,
                  estimatedTime: proposalData.estimatedTime || metadata?.estimatedTime || ''
                },
                parties: {
                  client: {
                    userid: clientId,
                    name: clientUser.name || clientUser.username,
                    email: clientUser.email,
                    avatar: clientUser.avatar,
                    metadata: new Map([
                      ['isVerified', clientUser.isVerified || false],
                      ['totalOrders', clientUser.totalOrders || 0],
                      ['rating', clientUser.rating || 0]
                    ])
                  },
                  booster: {
                    userid: boosterId,
                    name: boosterUser.name || boosterUser.username,
                    email: boosterUser.email,
                    avatar: boosterUser.avatar,
                    rating: boosterUser.rating || 0,
                    metadata: new Map([
                      ['isVerified', boosterUser.isVerified || false],
                      ['totalBoosts', boosterUser.totalBoosts || 0],
                      ['completedBoosts', boosterUser.completedBoosts || 0]
                    ])
                  }
                },
                financial: {
                  totalAmount: proposalPrice,
                  currency: 'BRL',
                  paymentStatus: 'pending'
                },
                status: 'active'
              });
              
              agreement.addAction('created', clientId, { proposalId: actualProposalId });
              await agreement.save();
              
              // Atualiza conversa com agreementId
              acceptedConv.metadata = acceptedConv.metadata || new Map();
              acceptedConv.metadata.set('latestAgreementId', agreement.agreementId);
              await acceptedConv.save();
              
              console.log(`‚úÖ [Proposal Accept] Agreement created: ${agreement.agreementId}`);
              console.log('‚úÖ [Proposal Accept] Agreement saved successfully with conversationId:', conversationId);
              
              // ‚úÖ NOVO: DEBITAR cliente imediatamente (ESCROW) ao aceitar proposta
              try {
                console.log('üí∞ [Proposal Accept] Debitando cliente (escrow)...');
                
                const User = require('../models/User');
                const WalletLedger = require('../models/WalletLedger');
                const round2 = (n) => Math.round((n + Number.EPSILON) * 100) / 100;
                
                // Buscar cliente novamente para ter saldo atualizado
                const clientForDebit = await User.findById(clientId);
                const clientBalanceBefore = round2(clientForDebit.walletBalance || 0);
                
                // Verificar saldo suficiente
                if (clientBalanceBefore < proposalPrice) {
                  throw new Error(`Saldo insuficiente. Necess√°rio: R$ ${proposalPrice.toFixed(2)}, Dispon√≠vel: R$ ${clientBalanceBefore.toFixed(2)}`);
                }
                
                const clientBalanceAfter = round2(clientBalanceBefore - proposalPrice);
                clientForDebit.walletBalance = clientBalanceAfter;
                await clientForDebit.save();
                
                // Criar registro no WalletLedger (cliente - d√©bito escrow)
                await WalletLedger.create({
                  userId: clientId,
                  txId: null,
                  direction: 'debit',
                  reason: 'boosting_escrow',
                  amount: proposalPrice,
                  operationId: `boosting_escrow:${agreement._id}`,
                  balanceBefore: clientBalanceBefore,
                  balanceAfter: clientBalanceAfter,
                  metadata: {
                    source: 'boosting',
                    agreementId: agreement._id.toString(),
                    conversationId: conversationId,
                    boosterId: boosterId.toString(),
                    price: Number(proposalPrice),
                    feePercent: 0.05,
                    type: 'boosting_service',
                    serviceName: 'Servi√ßo de Boosting',
                    providerName: boosterUser.name || 'Booster',
                    status: 'escrowed' // ‚úÖ Indica que est√° em escrow
                  }
                });
                
                // Atualizar Agreement para indicar que pagamento foi reservado
                agreement.financial.paymentStatus = 'escrowed';
                await agreement.save();
                
                console.log('‚úÖ [Proposal Accept] Cliente debitado (escrow):', {
                  clientId: clientId.toString(),
                  amount: proposalPrice,
                  balanceBefore: clientBalanceBefore,
                  balanceAfter: clientBalanceAfter,
                  status: 'escrowed'
                });
              } catch (escrowError) {
                console.error('‚ùå [Proposal Accept] Erro ao debitar cliente (escrow):', escrowError.message);
                
                // Reverter Agreement se d√©bito falhou
                await Agreement.deleteOne({ _id: agreement._id });
                
                throw new Error(`Erro ao processar pagamento: ${escrowError.message}`);
              }
              
              agreementCreated = agreement;
            } else {
              console.warn('‚ö†Ô∏è [Proposal Accept] Client or Booster user not found for Agreement creation');
            }
          } else {
            console.log(`‚ÑπÔ∏è [Proposal Accept] Agreement already exists: ${existingAgreement.agreementId}`);
            agreementCreated = existingAgreement;
          }
      } catch (agreementError) {
        console.error('‚ùå [Proposal Accept] CRITICAL ERROR creating Agreement:', agreementError.message);
        console.error('‚ùå [Proposal Accept] Stack trace:', agreementError.stack);
        console.error('‚ùå [Proposal Accept] This will prevent delivery confirmation!');
        
        // Log dados detalhados para debug
        console.error('‚ùå [Proposal Accept] Failed with data:', {
          conversationId,
          actualProposalId,
          clientId,
          boosterId,
          metadata: JSON.stringify(metadata, null, 2)
        });
        
        // ‚ö†Ô∏è IMPORTANTE: Agreement √© CR√çTICO para confirma√ß√£o de entrega
        // Propagar erro para impedir aceita√ß√£o
        throw agreementError;
      }
      
      // 3. Somente AP√ìS criar Agreement, aceitar a conversa
      acceptedConv.isTemporary = false;
      acceptedConv.status = 'accepted';
      acceptedConv.expiresAt = null;
      acceptedConv.boostingStatus = 'active';
      await acceptedConv.save();
      console.log('‚úÖ [Proposal Accept] Conversation accepted locally:', acceptedConv._id);
      
    } catch (localError) {
      console.error('‚ùå [Proposal Accept] FATAL ERROR accepting locally:', localError.message);
      console.error('‚ùå [Proposal Accept] Stack:', localError.stack);
      
      // ‚ö†Ô∏è RETORNAR ERRO para o cliente - N√ÉO continuar se Agreement falhou
      return res.status(500).json({
        success: false,
        message: 'Erro cr√≠tico ao aceitar proposta. Por favor, tente novamente.',
        error: localError.message,
        details: 'O Agreement n√£o p√¥de ser criado. Isso √© necess√°rio para confirmar a entrega posteriormente.'
      });
    }
    
    // Tenta sincronizar com API principal (n√£o-bloqueante)
    let apiResponse = null;
    let apiSyncSuccess = false;
    
    // Se proposalId ainda est√° no formato composto, usa o boostingId
    const finalProposalId = actualProposalId.includes('_') ? boostingId : actualProposalId;
    
    try {
      const forwardUrl = `${process.env.HACKLOTE_API_URL || 'https://zenithggapi.vercel.app/api'}/boosting-requests/${boostingId}/proposals/${finalProposalId}/accept`;
      
      console.log(`üîó [Proposal Accept] Attempting sync with main API: ${forwardUrl}`);
      console.log(`üîó [Proposal Accept] Final IDs: boostingId=${boostingId}, proposalId=${finalProposalId}`);
      
      apiResponse = await axios.post(forwardUrl, {
        conversationId,
        boosterId,
        clientId,
        metadata
      }, {
        headers: {
          'Authorization': req.headers.authorization,
          'Content-Type': 'application/json'
        },
        timeout: 10000 // 10s timeout
      });
      
      console.log(`‚úÖ [Proposal Accept] Main API sync successful:`, apiResponse.data);
      apiSyncSuccess = true;
      
    } catch (apiError) {
      console.warn('‚ö†Ô∏è [Proposal Accept] Main API sync failed (continuing anyway):', apiError.message);
      if (apiError.response) {
        console.warn('‚ö†Ô∏è [Proposal Accept] API Error:', apiError.response.status, apiError.response.data);
      }
      // Continua mesmo com erro na API principal
    }
    // Emite eventos WebSocket para atualiza√ß√£o em tempo real
    try {
      const webSocketServer = req.app.get('webSocketServer');
      if (webSocketServer) {
        console.log('üì° [Proposal Accept] Emitting WebSocket events for real-time updates...');
        
        // Dados da proposta aceita
        const acceptedProposalData = apiSyncSuccess && apiResponse?.data?.acceptedProposal 
          ? apiResponse.data.acceptedProposal 
          : {
              proposalId: actualProposalId,
              boostingId: boostingId,
              boosterId: boosterId,
              clientId: clientId,
              status: 'accepted',
              acceptedAt: new Date().toISOString()
            };
        
        // Evento 1: proposal:accepted
        const proposalAcceptedEvent = {
          type: 'proposal:accepted',
          data: {
            conversationId,
            proposalId: actualProposalId,
            boostingId,
            acceptedProposal: acceptedProposalData,
            status: 'accepted',
            acceptedAt: new Date().toISOString(),
            acceptedBy: 'client',
            clientId,
            boosterId
          }
        };
        
        if (clientId) {
          webSocketServer.sendToUser(clientId, proposalAcceptedEvent);
          console.log(`‚úÖ [Proposal Accept] 'proposal:accepted' sent to client: ${clientId}`);
        }
        
        if (boosterId) {
          webSocketServer.sendToUser(boosterId, proposalAcceptedEvent);
          console.log(`‚úÖ [Proposal Accept] 'proposal:accepted' sent to booster: ${boosterId}`);
        }
        
        // Evento 2: conversation:updated (atualiza UI)
        const conversationUpdateEvent = {
          type: 'conversation:updated',
          data: {
            conversationId,
            status: 'accepted',
            isTemporary: false,
            boostingStatus: 'active',
            updatedAt: new Date().toISOString(),
            conversation: acceptedConv ? {
              _id: acceptedConv._id,
              status: acceptedConv.status,
              isTemporary: acceptedConv.isTemporary,
              boostingStatus: acceptedConv.boostingStatus,
              participants: acceptedConv.participants
            } : null
          }
        };
        
        if (clientId) {
          webSocketServer.sendToUser(clientId, conversationUpdateEvent);
          console.log(`‚úÖ [Proposal Accept] 'conversation:updated' sent to client: ${clientId}`);
        }
        
        if (boosterId) {
          webSocketServer.sendToUser(boosterId, conversationUpdateEvent);
          console.log(`‚úÖ [Proposal Accept] 'conversation:updated' sent to booster: ${boosterId}`);
        }
        
        console.log('‚úÖ [Proposal Accept] All WebSocket events emitted successfully');
      } else {
        console.warn('‚ö†Ô∏è [Proposal Accept] WebSocket server not available for real-time updates');
      }
    } catch (wsError) {
      console.error('‚ùå [Proposal Accept] Error emitting WebSocket events:', wsError);
      console.error('‚ùå [Proposal Accept] WebSocket error stack:', wsError.stack);
    }
    

    // Retorna resposta apropriada
    if (apiSyncSuccess && apiResponse) {
      console.log('‚úÖ [Proposal Accept] Returning API response');
      return res.json(apiResponse.data);
    } else {
      console.log('‚úÖ [Proposal Accept] Returning local acceptance response');
      return res.json({
        success: true,
        message: 'Proposta aceita com sucesso',
        acceptedProposal: {
          proposalId: proposalId,
          actualProposalId: actualProposalId,
          boostingId: boostingId,
          status: 'accepted',
          acceptedAt: new Date().toISOString(),
          conversationId: conversationId,
          boosterId: boosterId,
          clientId: clientId
        },
        conversation: acceptedConv ? {
          _id: acceptedConv._id,
          status: acceptedConv.status,
          isTemporary: acceptedConv.isTemporary,
          boostingStatus: acceptedConv.boostingStatus
        } : null,
        sync: {
          mainApi: apiSyncSuccess,
          warning: !apiSyncSuccess ? 'Main API sync failed, but proposal was accepted locally' : null
        }
      });
    }
    
  } catch (error) {
    console.error('‚ùå [Proposal Accept] Error:', error.message);
    
    if (error.response) {
      console.error('‚ùå [Proposal Accept] API Error Response:', error.response.data);
      return res.status(error.response.status).json(error.response.data);
    }
    
    return res.status(500).json({
      success: false,
      message: 'Erro interno do servidor ao aceitar proposta',
      error: error.message
    });
  }
});

module.exports = router;
