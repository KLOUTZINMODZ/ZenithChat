const express = require('express');
const axios = require('axios');
const logger = require('../utils/logger');
const paymentCacheService = require('../services/paymentCacheService');
const highlightRetryService = require('../services/highlightRetryService');
const MarketItem = require('../models/MarketItem');
const router = express.Router();

// Fun√ß√£o para aplicar highlights na API principal (Vercel)
const applyHighlightToMainAPI = async (externalReference, paymentData = null) => {
  let userId = null; // Definir fora do try para acessar no catch
  
  try {
    // Extrair informa√ß√µes da refer√™ncia externa
    // Formato esperado: marketplace_highlight_USER_ID_TIMESTAMP
    const parts = externalReference.split('_');
    if (parts.length < 4 || parts[0] !== 'marketplace' || parts[1] !== 'highlight') {
      throw new Error('Formato de refer√™ncia externa inv√°lido');
    }
    
    userId = parts[2];
    const timestamp = parts[3];
    
    // Cache payment data se fornecido
    if (paymentData) {
      paymentCacheService.storePaymentInfo(paymentData.id, paymentData);
    }
    
    logger.info('üîÑ Aplicando highlight na API principal para userId:', userId);
    logger.info('üìã Dados extra√≠dos do pagamento:', { userId, timestamp, externalReference });
    
    // Chamar API principal na Vercel para aplicar highlight
    const vercelApiUrl = process.env.VERCEL_API_URL || 'https://zenithapi-steel.vercel.app';
    
    // Tentar buscar itens do cache primeiro
    const cachedItems = paymentCacheService.getMarketplaceItems(externalReference);
    
    const response = await axios.post(`${vercelApiUrl}/api/marketplace-highlights-internal`, {
      userId: userId, // Manter como string (ObjectId)
      externalReference,
      durationDays: 14,
      cachedItems: cachedItems ? cachedItems.items : null
    }, {
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Source': 'HackloteChatApi',
        'Authorization': `Bearer ${process.env.VERCEL_API_SECRET}`
      },
      timeout: 30000
    });
    
    if (response.data.success) {
      logger.info('‚úÖ Highlight aplicado com sucesso na API principal:', response.data);
      return {
        success: true,
        message: 'Highlight aplicado com sucesso',
        data: response.data.data
      };
    } else {
      logger.error('‚ùå Erro na resposta da API principal:', response.data);
      return {
        success: false,
        message: response.data.message || 'Erro na API principal',
        error: 'MAIN_API_ERROR'
      };
    }
  } catch (error) {
    logger.error('‚ùå Erro ao comunicar com API principal:', error.message);
    
    // Adicionar ao retry queue se for erro de conectividade
    if (paymentData && error.code === 'ECONNREFUSED' || error.response?.status >= 500) {
      const highlightData = {
        userId,
        externalReference,
        durationDays: 14
      };
      
      paymentCacheService.addPendingHighlight(paymentData.id, highlightData);
      logger.info('‚è≥ Highlight adicionado √† fila de retry devido a erro de conectividade');
    }
    
    return {
      success: false,
      message: 'Erro ao conectar com API principal',
      error: 'MAIN_API_CONNECTION_ERROR'
    };
  }
};

// Fun√ß√£o para processar notifica√ß√£o do Mercado Pago
const processMercadoPagoNotification = async (notification) => {
  try {
    logger.info('üí≥ Processando notifica√ß√£o do Mercado Pago:', notification);
    
    // Verificar tipo de notifica√ß√£o
    if (notification.type !== 'payment') {
      logger.info('‚ö†Ô∏è Tipo de notifica√ß√£o ignorado:', notification.type);
      return { success: true, message: 'Tipo de notifica√ß√£o ignorado' };
    }
    
    const paymentId = notification.data?.id;
    if (!paymentId) {
      logger.warn('‚ö†Ô∏è ID do pagamento n√£o encontrado na notifica√ß√£o');
      return { success: false, message: 'ID do pagamento n√£o encontrado' };
    }
    
    logger.info('üîç Consultando detalhes do pagamento no Mercado Pago:', paymentId);
    
    // Fazer chamada real para a API do Mercado Pago
    let paymentDetails;
    try {
      const mpResponse = await axios.get(
        `https://api.mercadopago.com/v1/payments/${paymentId}`,
        {
          headers: {
            'Authorization': `Bearer ${process.env.MERCADO_PAGO_ACCESS_TOKEN}`
          },
          timeout: 10000
        }
      );
      
      paymentDetails = mpResponse.data;
      logger.info('üí∞ Detalhes do pagamento obtidos da API do Mercado Pago:', {
        id: paymentDetails.id,
        status: paymentDetails.status,
        external_reference: paymentDetails.external_reference,
        transaction_amount: paymentDetails.transaction_amount
      });
    } catch (error) {
      logger.error('‚ùå Erro ao consultar API do Mercado Pago:', error.message);
      
      // Retornar erro se n√£o conseguir acessar API do Mercado Pago
      return {
        success: false,
        message: 'Erro ao consultar detalhes do pagamento no Mercado Pago',
        error: 'MERCADOPAGO_API_ERROR'
      };
    }
    
    logger.info('üí∞ Detalhes do pagamento obtidos:', paymentDetails);
    
    // Processar apenas pagamentos aprovados
    if (paymentDetails.status === 'approved') {
      const result = await applyHighlightToMainAPI(paymentDetails.external_reference, paymentDetails);
      
      if (result.success) {
        logger.info('‚úÖ Highlight aplicado com sucesso ap√≥s confirma√ß√£o de pagamento');
        
        // Enviar notifica√ß√£o ao usu√°rio sobre confirma√ß√£o do pagamento
        try {
          // Extrair userId real da external_reference
          // Formato esperado: "marketplace_highlight_USERID_TIMESTAMP"
          const refParts = paymentDetails.external_reference.split('_');
          const userId = refParts.length >= 4 ? refParts[2] : null;
          
          if (userId) {
            // Usar comunica√ß√£o direta em vez de HTTP request
            const NotificationIntegrationService = require('../services/notificationIntegrationService');
            const notificationService = new NotificationIntegrationService();
            
            await notificationService.sendNotification(userId, {
              type: 'marketplace_highlight_confirmed',
              title: 'üéâ Destaque Ativado!',
              message: `Seus itens do marketplace foram destacados com sucesso. O destaque ficar√° ativo por 14 dias.`,
              data: {
                highlightedItems: result.data?.highlightedItems || [],
                totalItems: result.data?.totalItems || 0,
                expiresAt: result.data?.highlightExpires
              }
            });
            
            logger.info('‚úÖ Notifica√ß√£o de confirma√ß√£o enviada ao usu√°rio via WebSocket direto');
          } else {
            logger.warn('‚ö†Ô∏è UserId inv√°lido extra√≠do da refer√™ncia externa');
          }
        } catch (error) {
          logger.warn('‚ö†Ô∏è Erro ao enviar notifica√ß√£o ao usu√°rio:', error.message);
        }
        
        return {
          success: true,
          message: 'Pagamento confirmado e highlight aplicado',
          data: result.data
        };
      } else {
        logger.error('‚ùå Erro ao aplicar highlight ap√≥s pagamento:', result.message);
        return {
          success: false,
          message: result.message,
          error: result.error
        };
      }
    } else {
      logger.info(`‚ö†Ô∏è Pagamento com status ${paymentDetails.status}, n√£o processando highlight`);
      return {
        success: true,
        message: `Pagamento com status ${paymentDetails.status}`
      };
    }
  } catch (error) {
    logger.error('‚ùå Erro ao processar notifica√ß√£o do Mercado Pago:', error);
    return {
      success: false,
      message: error.message,
      error: 'NOTIFICATION_PROCESSING_ERROR'
    };
  }
};

// Webhook para receber notifica√ß√µes do Mercado Pago
router.post('/mercadopago-webhook', async (req, res) => {
  logger.info('üîî Webhook Mercado Pago recebido na HackloteChatApi');
  
  try {
    // Extrair dados do webhook do Mercado Pago
    let notification = {};
    
    // Verificar se h√° dados na query string (formato comum do Mercado Pago)
    if (req.query.type && req.query['data.id']) {
      notification = {
        type: req.query.type,
        data: { id: req.query['data.id'] }
      };
      logger.info('üì• Notifica√ß√£o extra√≠da da query string:', notification);
    } 
    // Verificar se h√° dados no body
    else if (req.body && typeof req.body === 'object') {
      notification = req.body;
      logger.info('üì• Notifica√ß√£o extra√≠da do body:', notification);
    }
    // Verificar par√¢metros da URL (formato alternativo)
    else if (req.query.id && req.query.topic) {
      notification = {
        type: req.query.topic === 'payment' ? 'payment' : req.query.topic,
        data: { id: req.query.id }
      };
      logger.info('üì• Notifica√ß√£o extra√≠da dos par√¢metros URL:', notification);
    }
    
    // Validar se conseguimos extrair uma notifica√ß√£o v√°lida
    if (!notification.type || !notification.data?.id) {
      logger.warn('‚ö†Ô∏è Estrutura de notifica√ß√£o inv√°lida ou incompleta');
      logger.debug('Query:', req.query);
      logger.debug('Body:', req.body);
      
      // Responder com sucesso para evitar reenvios do Mercado Pago
      return res.status(200).json({
        success: true,
        message: 'Webhook recebido mas estrutura inv√°lida'
      });
    }
    
    // Processar apenas notifica√ß√µes de pagamento
    if (notification.type !== 'payment') {
      logger.info(`‚ö†Ô∏è Tipo de notifica√ß√£o '${notification.type}' ignorado`);
      return res.status(200).json({
        success: true,
        message: 'Tipo de notifica√ß√£o ignorado'
      });
    }
    
    // Processar notifica√ß√£o
    const result = await processMercadoPagoNotification(notification);
    
    res.status(200).json({
      success: true,
      message: result.message || 'Webhook processado',
      data: result.data || null
    });
    
  } catch (error) {
    logger.error('‚ùå Erro no webhook marketplace Mercado Pago:', error);
    
    // Sempre responder com 200 para evitar reenvios desnecess√°rios
    res.status(200).json({
      success: false,
      message: 'Erro processado, webhook recebido'
    });
  }
});

// Endpoint de teste para simular webhook do Mercado Pago
router.post('/test-webhook', async (req, res) => {
  logger.info('üß™ Teste de webhook recebido');
  
  try {
    const { userId, paymentId, status = 'approved' } = req.body;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        message: 'userId √© obrigat√≥rio para o teste'
      });
    }
    
    // Simular notifica√ß√£o do Mercado Pago
    const testNotification = {
      type: 'payment',
      data: {
        id: paymentId || `test_payment_${Date.now()}`
      }
    };
    
    logger.info('üîÑ Processando notifica√ß√£o de teste:', testNotification);
    
    const result = await processMercadoPagoNotification(testNotification);
    
    res.json({
      success: true,
      message: 'Teste de webhook processado',
      testNotification,
      result
    });
  } catch (error) {
    logger.error('‚ùå Erro no teste de webhook:', error);
    res.status(500).json({
      success: false,
      message: 'Erro no teste de webhook',
      error: error.message
    });
  }
});

// Health check espec√≠fico para webhooks
router.get('/health', (req, res) => {
  res.json({
    service: 'Marketplace Webhook Service',
    status: 'healthy',
    timestamp: new Date().toISOString(),
    endpoints: {
      webhook: 'POST /marketplace-webhook/mercadopago-webhook',
      test: 'POST /marketplace-webhook/test-webhook'
    },
    configuration: {
      vercelApiUrl: process.env.VERCEL_API_URL || 'not configured',
      hasVercelSecret: !!process.env.VERCEL_API_SECRET
    }
  });
});

module.exports = router;
