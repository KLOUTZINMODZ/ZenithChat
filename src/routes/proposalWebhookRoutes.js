const express = require('express');
const router = express.Router();
const logger = require('../utils/logger');

/**
 * Webhook para receber notifica√ß√µes de novas propostas da API Vercel
 * Emite eventos WebSocket em tempo real para todos os usu√°rios inscritos
 */
router.post('/new-proposal', async (req, res) => {
  try {
    const { boostingId, proposal, secret } = req.body;
    
    // Validar secret para seguran√ßa
    if (secret !== process.env.WEBHOOK_SECRET) {
      logger.warn('‚ùå [Proposal Webhook] Invalid secret');
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }
    
    if (!boostingId || !proposal) {
      return res.status(400).json({
        success: false,
        message: 'boostingId and proposal are required'
      });
    }
    
    logger.info(`üì¢ [Proposal Webhook] New proposal received for boosting: ${boostingId}`);
    logger.info(`üì¢ [Proposal Webhook] Proposal ID: ${proposal._id}`);
    
    // Obter WebSocket server
    const webSocketServer = req.app.get('webSocketServer');
    
    if (!webSocketServer) {
      logger.warn('‚ö†Ô∏è [Proposal Webhook] WebSocket server not available');
      return res.status(503).json({
        success: false,
        message: 'WebSocket server not available'
      });
    }
    
    // Obter ProposalHandler e emitir evento
    const proposalHandler = webSocketServer.getProposalHandler();
    
    if (!proposalHandler) {
      logger.warn('‚ö†Ô∏è [Proposal Webhook] ProposalHandler not available');
      return res.status(503).json({
        success: false,
        message: 'ProposalHandler not available'
      });
    }
    
    // Notificar todos os usu√°rios inscritos neste boosting
    proposalHandler.notifyNewProposal(boostingId, proposal);
    
    logger.info(`‚úÖ [Proposal Webhook] Notification sent for boosting: ${boostingId}`);
    
    return res.json({
      success: true,
      message: 'Proposal notification sent',
      boostingId,
      proposalId: proposal._id
    });
    
  } catch (error) {
    logger.error('‚ùå [Proposal Webhook] Error:', error);
    return res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message
    });
  }
});

/**
 * Webhook para atualiza√ß√£o de proposta
 */
router.post('/update-proposal', async (req, res) => {
  try {
    const { boostingId, proposal, secret } = req.body;
    
    // Validar secret
    if (secret !== process.env.WEBHOOK_SECRET) {
      logger.warn('‚ùå [Proposal Update Webhook] Invalid secret');
      return res.status(401).json({
        success: false,
        message: 'Unauthorized'
      });
    }
    
    if (!boostingId || !proposal) {
      return res.status(400).json({
        success: false,
        message: 'boostingId and proposal are required'
      });
    }
    
    logger.info(`üîÑ [Proposal Update Webhook] Proposal updated for boosting: ${boostingId}`);
    
    const webSocketServer = req.app.get('webSocketServer');
    
    if (!webSocketServer) {
      return res.status(503).json({
        success: false,
        message: 'WebSocket server not available'
      });
    }
    
    const proposalHandler = webSocketServer.getProposalHandler();
    
    if (!proposalHandler) {
      return res.status(503).json({
        success: false,
        message: 'ProposalHandler not available'
      });
    }
    
    // Notificar sobre atualiza√ß√£o
    proposalHandler.notifyProposalUpdate(boostingId, proposal);
    
    logger.info(`‚úÖ [Proposal Update Webhook] Update notification sent for boosting: ${boostingId}`);
    
    return res.json({
      success: true,
      message: 'Proposal update notification sent',
      boostingId,
      proposalId: proposal._id
    });
    
  } catch (error) {
    logger.error('‚ùå [Proposal Update Webhook] Error:', error);
    return res.status(500).json({
      success: false,
      message: 'Internal server error',
      error: error.message
    });
  }
});

module.exports = router;
