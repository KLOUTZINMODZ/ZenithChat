# Sistema de Persist√™ncia de Imagens no Banco de Dados

## üìã Vis√£o Geral

Implementado sistema robusto de persist√™ncia de imagens no MongoDB para garantir que **nenhuma imagem seja perdida**, mesmo se arquivos no disco forem deletados. O sistema mant√©m **100% de compatibilidade** com URLs existentes no frontend.

---

## üéØ Problema Resolvido

**Antes:**
- Imagens salvas apenas no disco (`/uploads`)
- Imagens sumindo (404) quando arquivos eram deletados
- Sem backup ou redund√¢ncia

**Depois:**
- Imagens salvas no MongoDB (permanente)
- Imagens tamb√©m salvas no disco (compatibilidade)
- Middleware inteligente com fallback autom√°tico
- URLs continuam funcionando sem mudan√ßas no frontend

---

## üèóÔ∏è Arquitetura Implementada

### **1. Modelo de Banco de Dados**
**Arquivo:** `src/models/UploadedImage.js`

```javascript
{
  imageId: String,              // ID √∫nico (ex: 1735938234_abc123)
  conversationId: String,        // Conversa associada
  
  // Buffers das imagens (nunca ser√£o deletados)
  fullImage: Buffer,            // AVIF full (1920x1920)
  thumbImage: Buffer,           // AVIF thumb (512x512)
  fullImageJpeg: Buffer,        // JPEG fallback full
  thumbImageJpeg: Buffer,       // JPEG fallback thumb
  
  // Metadados
  metadata: {
    originalName: String,
    originalSize: Number,
    originalMimeType: String,
    width: Number,
    height: Number
  },
  
  // URLs originais (compatibilidade)
  urls: {
    full: String,               // /uploads/conv/2024/1/image.avif
    thumb: String,
    fullJpeg: String,
    thumbJpeg: String
  },
  
  uploadedBy: ObjectId,
  uploadedAt: Date,
  permanent: Boolean (default: true) // Flag para NUNCA deletar
}
```

**√çndices:**
- `imageId` (unique)
- `conversationId` + `uploadedAt`

---

### **2. Rotas de Upload Modificadas**
**Arquivo:** `src/routes/uploadRoutes.js`

**POST `/api/upload/image`** (multipart/form-data)
**POST `/api/upload/image-base64`** (JSON base64)

**Fluxo:**
1. Recebe imagem
2. Processa com Sharp (4 vers√µes)
3. **Salva no disco** (compatibilidade com sistema antigo)
4. **Salva no MongoDB** (persist√™ncia garantida)
5. Retorna URLs normais

```javascript
// Ambas rotas salvam no banco de dados
await UploadedImage.create({
  imageId: baseName,
  conversationId: conversationId,
  fullImage: fullBuffer,        // ~200KB AVIF
  thumbImage: thumbBuffer,      // ~50KB AVIF
  fullImageJpeg: fullJpegBuffer,  // ~400KB JPEG
  thumbImageJpeg: thumbJpegBuffer, // ~100KB JPEG
  metadata: { ... },
  urls: { ... },
  permanent: true  // NUNCA SER√Å DELETADA
});
```

---

### **3. Middleware de Servir Imagens**
**Arquivo:** `src/middleware/imageServeMiddleware.js`

**Estrat√©gia de Fallback:**
```
Requisi√ß√£o ‚Üí Middleware ‚Üí MongoDB? ‚Üí Disco? ‚Üí 404
                           ‚úì Serve      ‚úì Serve
```

**Funcionamento:**
1. Intercepta `/uploads/**/*.{avif,jpg,jpeg,png}`
2. Extrai `imageId` da URL
3. Busca no MongoDB primeiro
4. Se encontrar: serve do banco (Buffer)
5. Se n√£o encontrar: `next()` ‚Üí express.static serve do disco
6. Cache agressivo: 1 ano

**Vantagens:**
- Zero mudan√ßas no frontend
- URLs antigas continuam funcionando
- Imagens novas sempre persistidas
- Performance otimizada com cache

---

### **4. Configura√ß√£o do Server**
**Arquivo:** `server.js`

```javascript
// ORDEM IMPORTA!
app.use('/uploads', imageServeMiddleware);  // 1¬∫: tenta banco
app.use('/uploads', express.static(...));   // 2¬∫: fallback disco
```

---

## üìä Estat√≠sticas de Armazenamento

**Por imagem:**
- Full AVIF: ~150-250KB
- Thumb AVIF: ~40-60KB
- Full JPEG: ~300-500KB
- Thumb JPEG: ~80-120KB
- **Total por upload: ~570KB-930KB**

**Exemplo com 1.000 imagens:**
- Tamanho m√©dio: ~750KB/imagem
- Total: ~750MB
- MongoDB suporta at√© 16MB por documento
- GridFS n√£o necess√°rio (cada imagem < 1MB)

---

## üîÑ Fluxo Completo

### **Upload:**
```
Frontend ‚Üí POST /api/upload/image
           ‚Üì
        Sharp processa (4 vers√µes)
           ‚Üì
        ‚îú‚îÄ‚Üí Disco: /uploads/conv/2024/1/img.avif
        ‚îî‚îÄ‚Üí MongoDB: UploadedImage.create({...})
           ‚Üì
        Retorna: { url: "/uploads/conv/2024/1/img.avif" }
```

### **Acesso:**
```
Frontend ‚Üí GET /uploads/conv/2024/1/img.avif
           ‚Üì
        Middleware intercepta
           ‚Üì
        MongoDB busca imageId
           ‚îú‚îÄ‚Üí Encontrou? ‚Üí Serve buffer (Cache 1 ano)
           ‚îî‚îÄ‚Üí N√£o? ‚Üí express.static serve do disco
```

---

## ‚úÖ Garantias

### **1. Persist√™ncia Total**
- ‚úÖ Imagens NUNCA s√£o deletadas do MongoDB
- ‚úÖ Flag `permanent: true` em todos documentos
- ‚úÖ Sem TTL ou cleanup autom√°tico

### **2. Compatibilidade**
- ‚úÖ URLs antigas funcionam (disco)
- ‚úÖ URLs novas funcionam (banco)
- ‚úÖ Zero mudan√ßas no frontend
- ‚úÖ Fallback autom√°tico

### **3. Performance**
- ‚úÖ Cache agressivo (1 ano)
- ‚úÖ ETag e Last-Modified
- ‚úÖ Buffers otimizados
- ‚úÖ `.lean()` nas queries

### **4. Redund√¢ncia**
- ‚úÖ Disco + Banco = 2 c√≥pias
- ‚úÖ Se disco falhar ‚Üí banco serve
- ‚úÖ Se banco falhar ‚Üí disco serve

---

## üöÄ Pr√≥ximos Passos (Opcional)

1. **Migra√ß√£o de Imagens Antigas:**
   - Script para importar imagens do disco para o banco
   - Arquivo: `scripts/migrateOldImages.js`

2. **Limpeza de Disco (Futuro):**
   - Ap√≥s confirmar que todas imagens est√£o no banco
   - Deletar arquivos antigos do disco
   - Economizar espa√ßo

3. **M√©tricas:**
   - Quantas imagens no banco
   - Taxa de hit/miss do middleware
   - Tamanho total usado

---

## üìù Logs

**Upload bem-sucedido:**
```
[UPLOAD] Image saved to database: 1735938234_abc123
```

**Servi√ßo do banco:**
```
[IMAGE_SERVE] Servindo do banco de dados: 1735938234_abc123 (245.3KB)
```

**Fallback para disco:**
```
[IMAGE_SERVE] N√£o encontrado no BD, tentando disco: 1735938234_abc123
```

---

## üõ°Ô∏è Seguran√ßa

- ‚úÖ URLs assinadas com timestamp + random
- ‚úÖ Valida√ß√£o de MIME types
- ‚úÖ Limite de 8MB por arquivo
- ‚úÖ CORS configurado
- ‚úÖ Sanitiza√ß√£o de paths

---

## üîß Manuten√ß√£o

**Verificar imagens no banco:**
```javascript
const count = await UploadedImage.countDocuments();
console.log(`Total de imagens persistidas: ${count}`);
```

**Buscar imagem espec√≠fica:**
```javascript
const img = await UploadedImage.findOne({ imageId: '1735938234_abc123' });
```

**Estat√≠sticas de tamanho:**
```javascript
const stats = await UploadedImage.aggregate([
  {
    $project: {
      totalSize: {
        $add: [
          { $bsonSize: "$fullImage" },
          { $bsonSize: "$thumbImage" },
          { $bsonSize: "$fullImageJpeg" },
          { $bsonSize: "$thumbImageJpeg" }
        ]
      }
    }
  },
  {
    $group: {
      _id: null,
      avgSize: { $avg: "$totalSize" },
      totalSize: { $sum: "$totalSize" }
    }
  }
]);
```

---

## ‚ú® Resultado Final

**üéØ Objetivo Alcan√ßado:**
- ‚úÖ Imagens **NUNCA** ser√£o perdidas
- ‚úÖ Sistema 100% retrocompat√≠vel
- ‚úÖ Frontend continua funcionando sem mudan√ßas
- ‚úÖ Redund√¢ncia disco + banco
- ‚úÖ Performance otimizada
- ‚úÖ Logs detalhados

**üöÄ Deploy:**
Basta reiniciar o servidor. O sistema come√ßa a funcionar imediatamente para novos uploads!
